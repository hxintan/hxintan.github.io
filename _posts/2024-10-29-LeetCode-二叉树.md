---
layout:     post
title:      LeetCode-二叉树
author:     黑矮皮卡
catalog: true
tags:
    - LeetCode
---

## 前中后遍历（深度优先遍历）
● 递归法：
    ⅰ. 确定递归函数的参数和返回值  
    ⅱ. 确定终止条件
    ⅲ. 确定单层递归的条件
● 迭代法 ：用栈的思想
```
//递归：前序遍历
class Solution {
  public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer>res=new ArrayList<Integer>();
    preorder(root,res);
    return res;
  }
  public void preorder(TreeNode root,List<Integer> res){
    if(root==null){
      return;
    }
    res.add(root.val);
    preorder(root.left,res);
    preorder(root.right,res);
  }
}
//迭代：
//前序遍历：中-左-右，入栈：中-右-左
//后序遍历：左-右-中，入栈：中-左-右，出栈：中-右-左， 翻转结果
//中序遍历：左-中-右，用指针遍历访问左下节点
```
## 层序遍历（广度优先遍历：用队列实现）
```
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
       Deque<TreeNode>que=new LinkedList<>();
       List<List<Integer>>res=new ArrayList<>(); 
       if(root!=null){
        que.add(root);}
       while(!que.isEmpty()){
        int k=que.size();
        List<Integer>tmp=new ArrayList<>();
        for(int i=0;i<k;i++){
            TreeNode node=que.poll();
            tmp.add(node.val);
            if(node.left!=null){
                que.add(node.left);}
            if(node.right!=null){
                que.add(node.right);}}
                    res.add(tmp); }
       return res;}}
```
### 层序遍历II
```
//将每层的结果添加到res的开头反转
   res.add(0, tmp);
二叉树右视图
while (!que.isEmpty()) {
    int k = que.size();
    TreeNode rightmost = null;
    for (int i = 0; i < k; i++) {
       TreeNode node = que.poll();                
        // 更新每层最后一个节点为 rightmost
        rightmost = node;                
        if (node.left != null) {
            que.add(node.left); }                
        if (node.right != null) {
            que.add(node.right);}}            
    // 将每层的最后一个节点值添加到结果
    if (rightmost != null) {
       res.add(rightmost.val);}}
```
### 二叉树层平均值
```
while (!que.isEmpty()) {
            int k = que.size();
            double sum = 0; // 用于累加每层节点的值            
            for (int i = 0; i < k; i++) {
                TreeNode node = que.poll();
                sum += node.val; // 累加节点值                
                if (node.left != null) {
                    que.add(node.left); }     
                if (node.right != null) {
                    que.add(node.right);}}            
            // 计算当前层的平均值并添加到结果
            res.add(sum / k); }
```
### N叉树层序遍历
```
Deque<Node>queue=new LinkedList<>();//TreeNode为二叉树，这里是N  
queue.addAll(node.children);//注意All大小写
```
### 每个数行中最大值
```
int max = Integer.MIN_VALUE; // 初始化最大值为最小整数
max = Math.max(max, node.val); // 更新当前层的最大值
res.add(max); // 将当前层的最大值添加到结果列表
```
### 填充每个节点的下一个右侧节点指针
```
for (int i = 0; i < k; i++) {
  Node node = que.poll();
  if (i < k - 1) {// 将当前节点next指向同层下一个节点
    node.next = que.peek();
    } return root; // 返回连接后的树的根节点
```
### 二叉树最大和最小深度
● minDepth ：在每层中遍历节点时，如果发现当前节点是叶子节点（没有左子树和右子树），则立即返回当前深度
● maxDepth ：在每层中遍历节点时，每次进入 while 循环都会增加深度，并在遍历所有节点后返回深度值
```
//最大：
int res = 0;
if (root != null) {
que.add(root);}
while (!que.isEmpty()) {
  int k = que.size(); // 当前层的节点数
  res++; // 每次进入循环表示深度增加
  for (int i = 0; i < k; i++) {}
  return res; // 返回树的最大深度 }}
```
```
// 最小：如果当前节点是叶子节点，返回当前深度
if (node.left == null && node.right == null) {
  return res;
```
## 翻转二叉树
```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null; }
        TreeNode tmp=root.left;
        root.left=root.right;
        root.right=tmp;
        invertTree(root.left);
        invertTree(root.right);
        return root;}}
```
## 对称二叉树
```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)return true;
        return compare(root.left,root.right);
    }
    private boolean compare(TreeNode left,TreeNode right){
        if(left==null&right==null)return true;
        if(left==null||right==null)return false;
        if(left.val!=right.val)return false;
        return compare(left.left,right.right)&&compare(left.right,right.left);
    }}
```
## 二叉树最大最小深度（递归）
```
//最大深度
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null)return 0;
        int ldep=maxDepth(root.left);
        int rdep=maxDepth(root.right);
        return Math.max(ldep,rdep)+1;
    }}
```
```
//最小深度
class Solution {
    public int minDepth(TreeNode root) {
       if(root==null)return 0;
       if(root.right==null)return minDepth(root.left)+1;
       if(root.left==null)return minDepth(root.right)+1;
       return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }}
```
